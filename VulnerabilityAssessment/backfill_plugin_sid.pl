#!/usr/bin/perl

# Written 2014
# Tim Brigham
# timbrigham@gmail.com

# This script locates any unlabeled NASL files (recent releases, etc) and updates the 
# Alienvault SID table with the plugin name, priority and name. 

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
	
use Getopt::Std;
use Data::Dumper;
use DBI;
use strict;



use File::Find qw(finddepth);
 my @files;
finddepth(sub {
	    return if($_ eq '.' || $_ eq '..');
	    push @files, $File::Find::name;
	  }, '/var/lib/openvas/plugins/');




my $content;

my $reconfig=0;


sub read_file
  {
    my $filename = @_[0];
    #print "$filename\n";
    my $localcontent;
    open(my $fh, '<', $filename) or die "cannot open file $filename";
    {
      local $/;
      $localcontent = <$fh>;
    }
    close($fh);
    return $localcontent;
  }

sub cparen{
    my ($value) = $content =~ m/@_\(\s*\"?([^"]*?)\"?\s*\)\s*\;/;
    return $value;
  }

sub named_pair{
    my ($value) = $content =~ m/name\:\s*\"@_\",\s*value:\s*\"?(.*?)\"?\);/;
    return $value;
  }

sub equal_pair{
    my ($value) = $content =~ m/@_\s*=\s*(.*);/;
    return $value;
  }

sub parse_priority
  {

    my $priority=@_[0];

    if( $priority eq "None" )
      {
	return 0;
      }
    if( $priority eq "Low" )
      {
	return 1;
      }
    if( $priority eq "Medium" )
      {
	return 2;
      }
    if( $priority eq "High" )
      {
	return 3;
      }
    if( $priority eq "Critical" )
      {
	return 4;
      }
    return 10;
  }

sub parse_vector
  {
    my $retval=0;

    my $vector = @_[0];
    #print "$vector\n";
    
    my %lhash = split /[:\/]/, $vector;
    
    if( $lhash{"AV"} eq "N" )
      {
	#print "AV=N Increment the retval by 2\n";
	$retval+=2;
      }
    if( $lhash{"AV"} eq "A" )
      {
	#print "AV=A Increment the retval by 1\n";
	$retval+=1;
      }

    if( $lhash{"AC"} eq "M" )
      {
	#print "AC=M Increment the retval by 1\n";
	$retval+=1;
      }
    if( $lhash{"AC"} eq "L" )
      {
	#print "AC=L Increment the retval by 2\n";
	$retval+=2;
      }
    
    if( $lhash{"Au"} eq "N" )
      {
	#print "Au=N Increment the retval by 2\n";
	$retval+=2;
      }

    if( $lhash{"Au"} eq "S" )
      {
	#print "Au=S Increment the retval by 1\n";
	$retval+=1;
      }

    if( $lhash{"C"} eq "P" )
      {
	#print "C=P Increment the retval by 1\n";
	$retval+=1;
      }
    if( $lhash{"C"} eq "C" )
      {
	#print "C=C Increment the retval by 2\n";
	$retval+=2;
      }

    if( $lhash{"I"} eq "P" )
      {
	#print "I=P Increment the retval by 1\n";
	$retval+=1;
      }
    if( $lhash{"I"} eq "C" )
      {
	#print "I=C Increment the retval by 2\n";
	$retval+=2;
      }

    if( $lhash{"A"} eq "P" )
      {
	#print "A=P Increment the retval by 1\n";
	$retval+=1;
      }
    if( $lhash{"A"} eq "C" )
      {
	#print "A=C Increment the retval by 2\n";
	$retval+=2;
      }
    $retval = int( $retval/2);
    #print "Returning $retval\n";
    #print "---------+++++++++++++++++++-----------------\n";
    return $retval;
  }



my $dbhost = `grep ^ossim_host= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbhost);
$dbhost = "localhost" if ($dbhost eq "");
my $dbuser = `grep ^ossim_user= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbuser);
my $dbpass = `grep ^ossim_pass= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbpass);


my $database="alienvault";
my $dsn = "dbi:mysql:$database:localhost:3306";

#print "$dbhost\n";
#print "$dbuser\n";
#print "$dbpass\n";


# Connect to the SQL database
my $dbh = DBI->connect($dsn, $dbuser , $dbpass)
 or die "Connection Error: $DBI::errstr\n";

# A search query to find all default entries for OpenVAS.
my $sql = "select sid from ( select sid from plugin_sid where plugin_id=3001 ) as X order by sid";
# Prepeare and run the query.
my $sth = $dbh->prepare($sql);
$sth->execute or die "SQL Error: $DBI::errstr\n";

# Build a hash containing the resulting output.

my $sids = $sth->fetchall_hashref('sid');


#print Dumper( $sids );

# Now get a list of all the NASL files in the OpenVAS library directory
#my @files = glob('/var/lib/openvas/plugins/*.nasl');

foreach ( @files )
  {
    # Parse and read each file.
    $content = read_file $_;
    my $script_id =          cparen "script_id";

    if( $script_id != '' && ! ( exists $sids->{ $script_id }->{sid} )  )
      {
	# Some older scripts don't have a script id. Ignore them. 
	# Some scripts will already have a valid SID in the database. Ignore them.


	# Although multiple fields are extracted here most of them aren't needed. 

	my $filename = $_;
	my $script_cve_id =      cparen "script_cve_id";
	my $script_bugtraq_id =  cparen "script_bugtraq_id";
	my $cvss_base =          named_pair "cvss_base";
	my $risk_factor =        named_pair "risk_factor";
	my $last_modified =      named_pair "last_modification";
	my $script_name =        cparen "script_name";
	my $vector =             named_pair "cvss_base_vector";
	
	my $reliability =         parse_vector $vector;
	my $priority =            parse_priority $risk_factor;


	# print  "File Name:        $filename\n";
	# print  "Script ID:        $script_id\n";
	# print  "CVE ID:           $script_cve_id\n";
	# print  "Bugtrack ID:      $script_bugtraq_id\n";
	# print  "CVSS Base:        $cvss_base\n";
	# print  "Risk Factor:      $risk_factor\n";
	# print  "Script Name:      $script_name\n";
	# print  "Last Modified:    $last_modified\n";
	# print  "Vector:           $vector\n";
	# print  "Reliability:      $reliability\n";
	# print  "Priority:         $priority\n";	
	# print  "---------------------------\n";

	$sql = "insert into plugin_sid values( 0, 3001, $script_id, null, $reliability, $priority, \"nessus: $script_name\", 0, null, null );";
	#print "$sql\n";
	$sth = $dbh->prepare($sql);
	$sth->execute or die "SQL Error: $DBI::errstr\n";
	$reconfig++;
      }
  }


  # Increase the reliability of the default SID. This will cause generic events for any assets
  # with a value of 2 or higher to create alerts (it bumps the risk value over 1).
  $sql="update plugin_sid set reliability=7 where sid=2000000000 and plugin_id=3001;";
  $sth = $dbh->prepare($sql);
  $sth->execute or die "SQL Error: $DBI::errstr\n";



  if( $reconfig )
    {
      `/usr/bin/sudo /usr/bin/alienvault-reconfig`
    }

exit 0;
