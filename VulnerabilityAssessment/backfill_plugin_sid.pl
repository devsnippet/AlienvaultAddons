#!/usr/bin/perl

# Copyright 2014 Tim Brigham
# 
# All rights reserved
# This script locates any unlabeled NASL files (recent releases, etc) and updates the 
# Alienvault SID table with the plugin name, priority and name. 

use Getopt::Std;
use Data::Dumper;
use DBI;
use strict;

#use File::Temp qw(tempfile);

#my ($fh, $filename) = tempfile();

my $content;


sub read_file
  {
    my $filename = @_[0];
    #print "$filename\n";
    my $localcontent;
    open(my $fh, '<', $filename) or die "cannot open file $filename";
    {
      local $/;
      $localcontent = <$fh>;
    }
    close($fh);
    return $localcontent;
  }

sub cparen{
    my ($value) = $content =~ m/@_\(\s*\"?([^"]*?)\"?\s*\)\s*\;/;
    return $value;
  }

sub named_pair{
    my ($value) = $content =~ m/name\:\s*\"@_\",\s*value:\s*\"?(.*?)\"?\);/;
    return $value;
  }

sub equal_pair{
    my ($value) = $content =~ m/@_\s*=\s*(.*);/;
    return $value;
  }

sub parse_priority
  {

    my $priority=@_[0];

    #print "$priority\n";

    if( $priority eq "None" )
      {
	return 0;
      }
    if( $priority eq "Low" )
      {
	return 1;
      }
    if( $priority eq "Medium" )
      {
	return 2;
      }
    if( $priority eq "High" )
      {
	return 3;
      }
    if( $priority eq "Critical" )
      {
	return 4;
      }
    return 10;
  }

sub parse_vector
  {
# These are the metrics that go in to a CVSS vector. 
# Metric: AV = AccessVector (Related exploit range)
# Possible Values: L = Local access, A = Adjacent network, N = Network
# Metric: AC = AccessComplexity (Required attack complexity)
# Possible Values: H = High, M = Medium, L = Low
# Metric: Au = Authentication (Level of authentication needed to exploit)
# Possible Values: N= None required, S= Requires single instance, M= Requires multiple instances
# Metric: C = ConfImpact (Confidentiality impact)
# Possible Values: N = None, P = Partial, C = Complete
# Metric: I = IntegImpact (Integrity impact)
# Possible Values: N = None, P = Partial, C = Complete
# Metric: A = AvailImpact (Availability impact)<> Possible Values: N = None, P = Partial, C = Complete

    my $retval=0;

    my $vector = @_[0];
    #print "$vector\n";
    
    my %lhash = split /[:\/]/, $vector;
    
    if( $lhash{"AV"} eq "N" )
      {
		#print "AV=N Increment the retval by 2\n";
		$retval+=2;
      }
    if( $lhash{"AV"} eq "A" )
      {
		#print "AV=A Increment the retval by 1\n";
		$retval+=1;
      }

    if( $lhash{"AC"} eq "M" )
      {
	#print "AC=M Increment the retval by 1\n";
		$retval+=1;
      }
    if( $lhash{"AC"} eq "L" )
      {
	#print "AC=L Increment the retval by 2\n";
		$retval+=2;
      }
    
    if( $lhash{"Au"} eq "N" )
      {
		#print "Au=N Increment the retval by 2\n";
		$retval+=2;
      }

    if( $lhash{"Au"} eq "S" )
      {
		#print "Au=S Increment the retval by 1\n";
		$retval+=1;
      }

    if( $lhash{"C"} eq "P" )
      {
		#print "C=P Increment the retval by 1\n";
		$retval+=1;
      }
    if( $lhash{"C"} eq "C" )
      {
		#print "C=C Increment the retval by 2\n";
		$retval+=2;
      }

    if( $lhash{"I"} eq "P" )
      {
		#print "I=P Increment the retval by 1\n";
		$retval+=1;
      }
    if( $lhash{"I"} eq "C" )
      {
		#print "I=C Increment the retval by 2\n";
		$retval+=2;
      }

    if( $lhash{"A"} eq "P" )
      {
		#print "A=P Increment the retval by 1\n";
		$retval+=1;
      }
    if( $lhash{"A"} eq "C" )
      {
		#print "A=C Increment the retval by 2\n";
		$retval+=2;
      }
	# The retval here isn't according to the standard 1-5 scale we use, divide in half. 
    $retval = int( $retval/2);
    #print "Returning $retval\n";
    #print "---------+++++++++++++++++++-----------------\n";
    return $retval;
  }


# Pull the current SQL settings out of the ossim.conf file. These lines are taken from another
# of the PERL scripts that shipped with OSSIM. 
my $dbhost = `grep ^ossim_host= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbhost);
$dbhost = "localhost" if ($dbhost eq "");
my $dbuser = `grep ^ossim_user= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbuser);
my $dbpass = `grep ^ossim_pass= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbpass);


my $database="alienvault";
my $dsn = "dbi:mysql:$database:localhost:3306";

#print "$dbhost\n";
#print "$dbuser\n";
#print "$dbpass\n";


# Connect to the SQL database
my $dbh = DBI->connect($dsn, $dbuser , $dbpass)
 or die "Connection Error: $DBI::errstr\n";

# A search query to find all default entries for OpenVAS.
my $sql = "select sid from ( select sid from plugin_sid where plugin_id=3001 ) as X order by sid";
# Prepare and run the query.
my $sth = $dbh->prepare($sql);
$sth->execute or die "SQL Error: $DBI::errstr\n";

# Build a hash containing the resulting output.
my $sids = $sth->fetchall_hashref('sid');
#print Dumper( $sids );

# Now get a list of all the NASL files in the OpenVAS library directory
my @files = glob('/var/lib/openvas/plugins/*.nasl');

foreach ( @files )
  {
    # Read and parse each file.
    $content = read_file $_;
    my $script_id =          cparen "script_id";

    if( $script_id != '' && ! ( exists $sids->{ $script_id }->{sid} )  )
      {
	# Some older scripts don't have a script id. Ignore them. 
	# Some scripts will already have a valid SID in the database. Ignore them.


	# Although multiple fields are extracted here most of them aren't needed. 

	my $filename = $_;
	my $script_cve_id =      cparen "script_cve_id";
	my $script_bugtraq_id =  cparen "script_bugtraq_id";
	my $cvss_base =          named_pair "cvss_base";
	my $risk_factor =        named_pair "risk_factor";
	my $last_modified =      named_pair "last_modification";
	my $script_name =        cparen "script_name";
	my $vector =             named_pair "cvss_base_vector";
	
	my $reliability =         parse_vector $vector;
	my $priority =            parse_priority $risk_factor;


	# print  "File Name:        $filename\n";
	# print  "Script ID:        $script_id\n";
	# print  "CVE ID:           $script_cve_id\n";
	# print  "Bugtrack ID:      $script_bugtraq_id\n";
	# print  "CVSS Base:        $cvss_base\n";
	# print  "Risk Factor:      $risk_factor\n";
	# print  "Script Name:      $script_name\n";
	# print  "Last Modified:    $last_modified\n";
	# print  "Vector:           $vector\n";
	# print  "Reliability:      $reliability\n";
	# print  "Priority:         $priority\n";	
	# print  "---------------------------\n";

	$sql = "insert into plugin_sid values( 0, 3001, $script_id, null, $reliability, $priority, \"nessus: $script_name\", 0, null, null );";
	print "$sql\n";
	$sth = $dbh->prepare($sql);
	$sth->execute or die "SQL Error: $DBI::errstr\n";
      }
  }
exit 0;
